package victor.training.spring.security.vulnerability;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.event.EventListener;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import jakarta.persistence.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import static java.util.stream.Collectors.toList;
import static jakarta.persistence.CascadeType.PERSIST;

@RequiredArgsConstructor
@RestController
public class DataExposure {
  private final BlogArticleRepo repo;

  @Value
  public static class BlogListDto {
    long id;
    String title;
    public BlogListDto(BlogArticle entity) {
      id = entity.getId();
      title = entity.getTitle();
    }
  }
  @GetMapping("api/vulnerability/articles")
  public List<BlogListDto> getAllArticles() {
    return repo.findAll().stream().map(BlogListDto::new).collect(toList());
  }

  @GetMapping("api/vulnerability/articles/{id}")
  // si-o batut joc de arhitectura. E lenes. putoare. nu stie sa faca un DTO
  public BlogArticle article(@PathVariable Long id) {
    return repo.findById(id).orElseThrow();
  }

  // FIX: returnezi doar DTO! obiecte dedicate!

  // poti scapa lucruri mai putin penale:
  // LoanContract.rejectedBy; // username


  //<editor-fold desc="Initial Data">
  @Transactional
  @EventListener(ApplicationStartedEvent.class)
  public void insertData() {
    for (int i = 0; i < 4; i++) {
      repo.save(new BlogArticle()
              .setTitle("Article "+i)
              .setText("Inspect the JSON response used to fill this page - article #"+i)
              .setDate(LocalDate.now().minusDays(2))
              .setComments(List.of(
                      new BlogArticleComment("Lame!",new BlogUser("King Julian", "kj@madagascar.com")),
                      new BlogArticleComment("Wow",new BlogUser("Julie", "julie.private@gmail.com"))
              ))
      );
    }
  }
  //</editor-fold>
}

@Data
@Entity
class BlogArticle {
  @Id
  @GeneratedValue
  private Long id;
  private String title;
  private String text;
  private LocalDate date;
  @OneToMany(cascade = PERSIST)
  private List<BlogArticleComment> comments = new ArrayList<>();
}

@Entity
@Data
class BlogArticleComment {
  @Id
  @GeneratedValue
  private Long id;
  private String text;
  @ManyToOne(cascade = PERSIST)
  private BlogUser author;
  protected BlogArticleComment() {} // for Hibernate only

  public BlogArticleComment(String text, BlogUser author) {
    this.text = text;
    this.author = author;
  }
}

@Data
@Entity
class BlogUser {
  @Id
  @GeneratedValue
  private Long id;
  private String name;
  protected BlogUser() {} // for Hibernate only
  @JsonIgnore // alta tampenie: poluezi modelul cu presentation concerns
  private String email;
  // Plus, maine uit sa ascund un field nou si-l expun accidental
  private String phone;

  public BlogUser(String name, String email) {
    this.name = name;
    this.email = email;
  }
}

interface BlogArticleRepo extends JpaRepository<BlogArticle, Long> {
}
