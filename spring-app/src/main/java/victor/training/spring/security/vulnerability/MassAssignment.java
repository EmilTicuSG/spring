package victor.training.spring.security.vulnerability;

import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.annotation.Scope;
import org.springframework.context.event.EventListener;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.scheduling.concurrent.ScheduledExecutorTask;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import victor.training.spring.security.vulnerability.MassAssignment.UpdatePlayerDetailsCommand;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.validation.Valid;

import static org.mapstruct.NullValuePropertyMappingStrategy.IGNORE;

@RestController
@RequiredArgsConstructor
public class MassAssignment {
  private final PlayerRepo playerRepo;
  private final PlayerMapper mapper;

  @GetMapping("api/vulnerability/player/details")
  public PlayerDto getPlayerDetails() {
    Player entity = playerRepo.findById(getCurrentPlayerId()).orElseThrow();
    return mapper.toDto(entity);
  }

  //<editor-fold desc="SOLUTION">
    @Data
  public static class UpdatePlayerDetailsCommand {
    private String fullName;
    private String country;
  }
  //</editor-fold>

//  ScheduledExecutor
//@RUnA
  //
//FIX: use dedicated Dtos for READ/CREATE/UPDATE/ whatever user-action you have
  @PutMapping("api/vulnerability/player/details")
  @Transactional
  public void updatePlayerDetails(@RequestBody UpdatePlayerDetailsCommand updateCommand) {
    // even if the update is never expected to receive cash in the json request on PUT /player,
    // Jackson will still unmarshall "cash" attribute into the "cash" field of the Dto.
    Player entity = playerRepo.findById(getCurrentPlayerId()).orElseThrow();
//    mapper.update(entity, updateCommand)
    //    if ;

    if (updateCommand.country.equals("MKD")) {
      flow3that_doesNotCheck();
      // what if a proxy (aspect) on every repo method checked that
      // on the current thread (ThreadLocal) there was a check already done
      // TRICKS: if you ever start a new thread, make sure you propagate the ThreadLocal variable. with
      // ThreadPoolTaskExecutor#setTaskDecorator()
    } else {

      flow3that_doesCheck();
    }
//    if ()
    entity.setFullName(updateCommand.getFullName());
//    if ()
    entity.setCountry(updateCommand.getCountry());
//    genericMapper(dto, entity);
  }

  private static void genericMapper(PlayerDto dto, Player entity) {
    if (dto.getCash() != null) {
      entity.setCash(dto.getCash());
    }
  }

  private static long getCurrentPlayerId() {
    return SecurityContextHolder.getContext().getAuthentication().getName().equals("user") ?
            1L : 3L;
  }

  //<editor-fold desc="initial data">
  @EventListener(ApplicationStartedEvent.class)
  public void insertInitialPlayers() {
    playerRepo.save(new Player().setId(1L).setCountry("RO").setUsername("ipopescu").setCash(100).setFullName("Ion Popescu"));
    playerRepo.save(new Player().setId(2L).setCountry("NL").setUsername("snoah").setCash(250).setFullName("Saar Noah"));
    playerRepo.save(new Player().setId(3L).setCountry("BE").setUsername("jdoe").setCash(150).setFullName("John Doe"));
  }
  //</editor-fold>
}

@Data
@Component
@Scope("request")
class ThreadWasAuthorizedHolder {
  boolean checked;
}

@Aspect
@Component
class AspectThatCheckedTheCurrentThreadWasAuthorizedBeforeCallingRepo {
  @Autowired
  private ThreadWasAuthorizedHolder holder;
//  private static final ThreadLocal<Boolean> WAS_CHECKED_ON_THREAD = ThreadLocal.withInitial(false);
  @Around("execution(* org.springframework.data.jpa.repository.JpaRepository+.*(..)) || execution(* org.springframework.data.jpa.repository.JpaSpecificationExecutor+.*(..))")
  public void method() {
    if (!holder.isChecked()) {
//    if (WAS_CHECKED_ON_THREAD.get() == Boolean.FALSE) {
      throw new IllegalArgumentException("");
    }
  }
  @Around("execution(* AuthorizationManager.*(..))")
  public void mark() {
    holder.setChecked(true);
//    WAS_CHECKED_ON_THREAD.set(true);
    // CAREFUL!!!!! to clear away the value at the end of the http request.
  }
}


@Data
class PlayerDto {
  private Long id;
  private String username;
  private String fullName;
  private String country;
  private Integer cash;
}

@Mapper(componentModel = "spring"
//       , nullValuePropertyMappingStrategy = IGNORE
)
      // NOT set in the Player @Entity a field in the Dto that is null
interface PlayerMapper {
  void update(@MappingTarget Player entity, UpdatePlayerDetailsCommand dto); // FIXME don't copy all fields

  PlayerDto toDto(Player entity);
}



@Entity
@Data
class Player {
  @Id
  private Long id;
  private String username;
  private String fullName;
  private String country;
  private Integer cash;

}

interface PlayerRepo extends JpaRepository<Player, Long> {
}